==================================================================
Introduction To ARC "Platform"
==================================================================

Conceptually, an ARC Platform is a SoC Family (one/more SoC(s)),
with one/more Boards based on those SoC(s).

Typically a Platform would be associated with an ARC Customer.

An SoC is essentially
  -Pre-canned Core Settings (cache line, MMU ver etc)
  -Any specific ARC Core extensions, which arc kernel either doesn't care
   about or if it does then it should have hooks to call-into it
  -Any other Soc specific devices, arc kernel doesn't care about anyways

==================================================================
How To add a Platform
==================================================================

(1) create arch/arc/plat-xxx

(2) create arch/arc/plat-xxx/Kconfig
	Define CONFIG_ARC_SOC_1
	Define CONFIG_ARC_SOC_1

(3) source above Kconfig in arch/arc/Kconfig

(4) Add entry in arch/arc/Makefile
	platform-$CONFIG_ARC_SOC_1 := xxx
	platform-$CONFIG_ARC_SOC_2 := xxx

==================================================================
How to Organise you Platform's Kconfig
==================================================================

(1) ARC Platform code organisation requires all SoC Family members, of a
    Platform plat-xxx, be enlisted in arch/arc/plat-xxx/Kconfig
    For more than 1 SoCs, this needs to be [ choice config* encdchoice ]

(2) Then depending on the complexity of family, the rest of organisation is
    left to the SoC folks. They may choose to have seperate Kconfig files for
    the following or decide to dump everything in arch/arc/plat-xxx/Kconfig
      -SoC specific stuff: e.g. if it has 32 vs. 64 b Cache Line
      -Board specific Stuff: e.g. List of Boards based on SoC and their quirks.

==================================================================
APIs/callbacks expected from platform code
==================================================================

(1) IRQ handling Hooks

void __init platform_irq_init(void);
void platform_free_irq(unsigned int irq);
int platform_setup_irq(unsigned int irq, unsigned int flags);
void platform_process_interrupt(int irq);
void platform_enable_irq(int irq);
void platform_disable_irq(int irq);

-setup/free/enable/disable are done with arch-common spinlock held,
 so there is no need for platform specific locking
-Look at arch/arc/kernel/irq.c for the order in which plat hooks are
 called w.r.t arch-common work.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(2) High Priority Device IRQs (ARCompact ISA Level 2 Interrupts)

-arch code exposes CONFIG_ARC_IRQ<n>_LV2 which are by default "hidden"
 in menuconfig. Only "select"ed by a deivce specific item in platform
 Kconfig (Look at arch/arc/plat-arcfpga/Kconfig)

-The arch core uses them to do anything needed at arc-common level:
   =setting up the vector table entries to common low/high priority ISRs
   =setting the corresponding bits in AUX_IRQ_LEV core reg

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
(3) SMP hooks

-API expected BY platform smp code (FROM arch-common code)

  int smp_ipi_irq_setup(int cpu, int irq);
    Takes @cpu and @irq to which the arch-common IPI ISR is hooked up

-APIs expected FROM platform smp code

  const char * arc_platform_smp_cpuinfo(void);
    returns a string containing info for /proc/cpuinfo

  void arc_platform_smp_init_cpu(void);
    Called from start_kernel_secondary to do any CPU local setup
    such as starting a timer, setting up IPI etc

  void arc_platform_ipi_send(cpumask_t callmap);
    Takes @cpumask to which IPI(s) would be sent.
    The actual msg-id/buffer is manager in arch-common code

  void arc_platform_ipi_clear(int cpu, int irq);
    Takes @cpu which got IPI at @irq to do any IPI clearing

-Note that if !CONFIG_SMP, the NULL defs for these are provided by
 arch-common code itself.
